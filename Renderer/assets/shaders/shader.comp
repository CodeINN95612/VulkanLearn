#version 460

layout(local_size_x = 256) in;

struct CubeRenderData {
	mat4 model;
	vec4 color;
};

layout(set = 0, binding = 0) readonly buffer TransformsStorageBuffer {
    CubeRenderData data[];
} transformStorageBuffer;

layout(set = 0, binding = 1) buffer VisibleTransformsStorageBuffer {
    CubeRenderData data[];
} visibleTransformStorageBuffer;

layout(set = 0, binding = 2) buffer IndirectDrawBuffer {
	uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;
    uint firstInstance;
} indirectDrawBuffer;

layout(set = 0, binding = 3) buffer CameraUniformBuffer {
	mat4 view;
	mat4 proj;
	mat4 viewProj;
    vec4 cameraPosition;
	float renderDistance;
} cameraUniformBuffer;

// Frustum planes
const int NUM_PLANES = 6;
vec4 frustumPlanes[NUM_PLANES];

void calculateFrustumPlanes() {
    mat4 vp = cameraUniformBuffer.viewProj;
    frustumPlanes[0] = vec4(vp[3] + vp[0]); // Left plane
    frustumPlanes[1] = vec4(vp[3] - vp[0]); // Right plane
    frustumPlanes[2] = vec4(vp[3] + vp[1]); // Bottom plane
    frustumPlanes[3] = vec4(vp[3] - vp[1]); // Top plane
    frustumPlanes[4] = vec4(vp[3] + vp[2]); // Near plane
    frustumPlanes[5] = vec4(vp[3] - vp[2]); // Far plane

    // Normalize the planes
    for (int i = 0; i < NUM_PLANES; i++) {
        frustumPlanes[i] /= length(frustumPlanes[i].xyz);
    }
}

bool isPointInFrustum(vec3 point) {
    for (int i = 0; i < NUM_PLANES; i++) {
        if (dot(vec4(point, 1.0), frustumPlanes[i]) < 0) {
            return false;
        }
    }
    return true;
}

bool IsVisible(CubeRenderData cubeData) {
    if (cubeData.color.a == 0.0) {
        return false;
    }

    // Get the cube's position from its model matrix
    vec3 cubePosition = vec3(cubeData.model[3]);

    // Check if the cube's center is within the frustum
    if (!isPointInFrustum(cubePosition)) {
        return false;
    }

    // Check if the cube is within render distance
    float distanceToCamera = distance(cubePosition, cameraUniformBuffer.cameraPosition.xyz);
    if (distanceToCamera > cameraUniformBuffer.renderDistance) {
        return false;
    }

    return true;
}

void main() {
	uint index = gl_GlobalInvocationID.x;
	if (index >= transformStorageBuffer.data.length()) {
		return;
	}

	CubeRenderData cubeData = transformStorageBuffer.data[index];
	if (IsVisible(cubeData)){
		uint visibleIndex = atomicAdd(indirectDrawBuffer.instanceCount, 1);
		visibleTransformStorageBuffer.data[visibleIndex] = cubeData;
	}

	if (index == 0) {
        indirectDrawBuffer.indexCount = 36;
        indirectDrawBuffer.firstIndex = 0;
        indirectDrawBuffer.vertexOffset = 0;
        indirectDrawBuffer.firstInstance = 0;
    }
}